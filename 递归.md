---
title: 递归
date: 2019-11-23
cover: http://m.qpic.cn/psb?/V13PUOHK4dI6ul/7kGt8drjR39vX.M1*8pboaKMXqJSGZz0ugrxxR1.dRo!/b/dDUBAAAAAAAA&bo=pQc4BAAAAAARB64!&rf=viewer_4
---

# 递归

写递归之前我在考虑到底要不要写递归，因为递归什么的我完全不懂啊，递来递去到底递给了谁，归来归去到底归去了哪，你要问我递归是个什么东西，对不起俺不知道。目前的话我对递归只有一些超级小小的了解罢了。

## 递归的定义

 这是一本书的官方术语：定义新对象或者新概念的基本规则是：定义中只能包含已经定义过的或者含义明显的术语。因此，如果对象根据他的自身来定义的话。就严重的违反了这一规则。导致恶性循环。而另一方面。有许多编程是根据自身来定义的。此时，需要给定义加上形式约束，以保证其满足存在性和唯一性。不违反上述的规则。这样的定义被称为递归定义。主要用于无限集合。定义无限集合时，俺们根本不可能列出所有的集合阿姨鸭，还有比如一些非常大的集合。所以俺们需要一种行之有效的方法来判断对象是否属于某个集合，而递归就是这样一种方法。

递归定义由两部分组成。第一部分被称为锚或者基例。列出了产生集合中其他元素的基本元素。第二部分给出由基本元素或已有对象产生新对象的构造规则。这些规则被反复使用，从而产生新对象。

**~~其实，完全不懂！！！~~**

来来来去百度找找定义

## 正儿八经的百度定义

程序调用自身的编程技巧称为递归（ recursion）。递归做为一种[算法](https://baike.baidu.com/item/算法)在[程序设计语言](https://baike.baidu.com/item/程序设计语言)中广泛应用。 一个过程或[函数](https://baike.baidu.com/item/函数)在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的[语句](https://baike.baidu.com/item/语句)来定义对象的[无限集合](https://baike.baidu.com/item/无限集合)。一般来说，递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。

**~~还是不懂对吧~~**

对了这句“它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，”很重要因为给俺们培训的老师上课一直在重复着句话啊哈哈哈哈

**~~但是其实还是不懂吧~~**

下面来举个搜到的例子，比如说我们小时候经常听到的从前有座山，山里有座庙，庙里有个和尚，和尚在讲故事，从前有座山，山里有座庙，庙里有个和尚，和尚在讲故事，从前有座山...

还有你从两面相对的镜子中看到的画面，其实都是抽象出来的递归现象，但是严格来说并不是递归，因为会一直重复下去，没有终止条件，那就称为死循环了。有关递归和死循环的异同我们之后会说到，那么现在先来了解一下什么是递归?

举个荔枝

先来简单大方的举个荔枝

## 阶乘

求一个n阶阶乘

那么我们应该怎么才能求出Fn呢；代码如下

```c++
#include<bits/stdc++.h>
using namespace std;
int f(int n){
    if(n==0)
    return 1;
    else return n*f(n-1);
}
int main(){
int n;
cin>>n;
cout<<n*f(n-1)<<endl;
}
```

这道题用过递归把问题分解成多个小问题首先函数接收一个整数n，然后限定一个递归结束条件【注意结束条件非常重要，否则将陷入死循环。】

```c++
读进->n
不满足结束条件
return n*f(n-1);
读进->n-1
 不满足结束条件
 return n*(n-1)*f(n-1-1)
 读进->n-1-1
 不满足结束条件
 return n*(n-1)(n-2)f(n-2-1)
```

但是只看这个代码本身我们还没办法弄清楚什么是递归

## 斐波那契数列

斐波那契数列（Fibonacci sequence），又称[黄金分割](https://baike.baidu.com/item/黄金分割/115896)数列、因[数学家](https://baike.baidu.com/item/数学家/1210991)列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“[兔子数列](https://baike.baidu.com/item/兔子数列/6849441)”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波那契数列以如下被以[递推](https://baike.baidu.com/item/递推/1740695)的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n>=3，n∈N*）

```c++
#include<bits/stdc++.h>
using namespace std;
int f(int n){
    if(n<=2)
    return 1;
    else return f(n-1)+f(n-2);
}
int main(){
int n;
cin>>n;
cout<<f(n-1)+f(n-2)<<endl;
system("pause");
}
```

斐波那契数列的原理和上面那一题的原理是一样的，把一个规模很大的问题分解成多个小问题，然后满足结束条件是结束递归。下面我们来看一道传说中的金典中的金典汉诺塔问题。

## 汉诺塔

法国数学家[爱德华·卢卡斯](https://baike.baidu.com/item/爱德华·卢卡斯)曾编写过一个印度的古老传说：在世界中心贝拿勒斯（在印度北部）的圣庙里，一块黄铜板上插着三根宝石针。印度教的主神[梵天](https://baike.baidu.com/item/梵天)在创造世界的时候，在其中一根针上从下到上地穿好了由大到小的64片金片，这就是所谓的汉诺塔。不论白天黑夜，总有一个僧侣在按照下面的法则移动这些金片：一次只移动一片，不管在哪根针上，小片必须在大片上面。僧侣们预言，当所有的金片都从梵天穿好的那根针上移到另外一根针上时，世界就将在一声霹雳中消灭，而[梵塔](https://baike.baidu.com/item/梵塔)、庙宇和众生也都将同归于尽。 

不管这个传说的可信度有多大，如果考虑一下把64片金片，由一根针上移到另一根针上，并且始终保持上小下大的顺序。这需要多少次移动呢?这里需要递归的方法。假设有n片，移动次数是f(n).显然f(1)=1,f(2)=3,f(3)=7，且f(k+1)=2*f(k)+1。此后不难证明f(n)=2^n-1。n=64时，

假如每秒钟一次，共需多长时间呢？一个平年365天有31536000 秒，闰年366天有31622400秒，平均每年31556952秒，计算一下：

18446744073709551615秒

这表明移完这些金片需要5845.54亿年以上，而地球存在至今不过45亿年，太阳系的预期寿命据说也就是数百亿年。真的过了5845.54亿年，不说太阳系和银河系，至少地球上的一切生命，连同梵塔、庙宇等，都早已经灰飞烟灭。

emmmmmmmmmmmm

灰飞烟灭也不一定啊，我讨厌这种带有强烈否定性的词

下面废话不多说直接码代码

```c++
#include <iostream>
#include <cstdio>

using namespace std;
 
void hannoi (int n, char A, char B, char C)　　// 把A盘里面的圆圈转移到C盘里面【A--C】。
{
    if (n == 1)
    {
        cout << "移动圆圈" << n << "从盘" << A << "盘" << C << endl;　　//把最后一个圆环从起点盘移动到目标盘。
    }
    else
    {
        hannoi (n-1, A, C, B);　　// 把N-1个圆环从起点盘移动到（当前）没有任何圆环的过度盘；通过B、C盘在此函数调用中调用位置的互换，来实现把N-1个圆环从A盘到B盘的转移【A--B】。
        cout << "移动圆圈" << n << "从盘" << A << "盘" << C << endl;
        hannoi (n-1, B, A, C);　　// 把N-1个圆环从国度盘移动到目标盘（模仿1和2的操作方法来实现）；通过A、B盘在此函数调用中位置的互换，来实现N-1个圆环从B盘到C盘的转移【B--C】。
    }
}
 
int main()
{
    int n;
    cin >> n;

    hannoi (n, 'a', 'b', 'c');

    system("pause");
    return 0;
}
```

我卡了！先放着吧

解释这件事我们先来看一个尾递归

```c++
void f(int n){
if(n>0){
f(n-1);
cout<<n<<" ";
f(n-1);
}
}
```

递归递归有递就有归

我们假如令n=3

```c#
n->3//我们先把n=3送进去
特判n是否大于零3>0;
f(3-1)->
f(2-1)->
f(1-1)->
f(0)->空
开始归
cout->n=1->1
于是对于第二个f(n-1)
f(0)
返回f(2-1)
cout->n=2->2
对于第二个f(n-1);
返回f(1),1>0;
f(1-1)->f(0);
cout<<n->1
返回f(3-1);
cout<<n->3
f(3-1)->2;
f(2-1)
f(1-1);
f(0)
返回f(2-1)
    f(1)->1>0
    f(1-1)->n=0;
cout<<n=1
   返回f(2-1);
cout<<n=2
    f(1)>0
    f(1-1);
cout<<n=1

```

跑完了爱递归过程大概就这样的啊

真的是非常不好理解呢推导过程也非常不容易啊推导都那么麻烦了啊怎么会写啊，什么只要理解就行了剩下交给计算机的话真是糟糕透了我说

汉诺塔内部的推导过程和这个尾递归的一模一样的啦；

要是还是不清楚那么再看一道李白打酒的例题吧；

    话说大诗人李白，一生好饮。幸好他从不开车。
    一天，他提着酒壶，从家里出来，酒壶中有酒2斗。他边走边唱：
    
    无事街上走，提壶去打酒。
    逢店加一倍，遇花喝一斗。
    
    这一路上，他一共遇到店5次，遇到花10次，已知最后一次遇到的是花，他正好把酒喝光了。 
    
    请你计算李白遇到店和花的次序，可以把遇店记为a，遇花记为b。则：babaabbabbabbbb 就是合理的次序。像这样的答案一共有多少呢？请你计算出所有可能方案的个数（包含题目给出的）。
    
    注意：通过浏览器提交答案。答案是个整数。不要书写任何多余的内容。
下面码上代码

```c++
#include<bits/stdc++.h>
 using namespace std;
int sum=0;
int f(int a,int b,int c)
{   // a:店的总数   b:花的总数    c:酒的初值
	// 任何初始状况，都有两个可能：先遇到店，或者先遇到花
   if(a>0)
    	f(a-1,b,c*2); // 逢店加一倍
   if(b>0)
    	f(a,b-1,c-1); // 遇花喝一斗
   if(a==0 && b==1 && c==1) //这个是满足要求的终止条件。没有店剩下，还剩一朵花和一斗酒
    	sum=sum+1;
    return sum;
}
int main()
{
    int numstore,numflower,jiu;
    
    printf("输入遇到店的次数：");
    scanf("%d",&numstore);
    
    printf("输入遇到花的次数：");
    scanf("%d",&numflower);
    
    printf("输入酒的初值：");
    scanf("%d",&jiu);
    
    f(numstore,numflower,jiu);
    printf("%d\n",sum);
    
    return 0;
}
```

这个我就不解释了吧

那么就到这里啦！！！